---
title: "Assignment 3:"
subtitle:  "Regional GDP Inequality in 4 Selected European Economies - "
author: "Kristoffer Tufta and Harald Vika"
date: last-modified
date-format: "dddd D MMM, YYYY"
csl: apa7.csl
lang: en-GB
format:
  html: default
  typst:
    papersize: a4
  pdf: 
    documentclass: article
    number-sections: true
    keep-tex: true
    papersize: A4
    fig-pos: "H"
abstract: ""
editor: 
  markdown: 
    wrap: sentence
echo: false
bibliography: references.bib
---

```{r}
#| label: setup
#| include: FALSE
#| message: false
#| warning: false
library (tidyverse)
library (PxWebApiData)
library(readxl)
library(purrr)
library(dineq)
library(psych)
library(flextable)
library(modelsummary)
library(lmtest)

```


# Part A: Testing development effects across subsets

```{r}
#Reading prewritten datasets
full_dataset <- readRDS("./data/tidyjoined2.rds")
xsection2017<- readRDS("./data/Gini_EUdata_full.rds") 
```


## Population Density

Breaking down our population density into logical segments could help us make a more accurate regression line.
If we take a look at our dataset, the data varies a lot, where we have many rural regions with low population density, and then some large city-regions with a much higher density.
To define the classifications, we will be taking inspiration from Eurostat's own definition on urban clusters and density, which divides Europe into:

-   *"Urban centre (high-density cluster): a cluster of contiguous grid cells of 1 km² (excluding diagonals) with a population density of at least 1 500 inhabitants per km² and collectively a minimum population of 50 000 inhabitants after gap-filling*
-   *Urban cluster (moderate-density cluster): a cluster of contiguous grid cells of 1 km² (including diagonals) with a population density of at least 300 inhabitants per km² and a minimum population of 5 000 inhabitants*
-   *Rural grid cells: grid cells that aren’t identified as urban centres or as urban clusters."*

[@populati]

Their classification is based on continuous cell clusters of one square kilometer cells , whereas ours is for whole NUTS2-regions, but we will be using the same break values.

```{r}
#Population density
xsection2017 <- xsection2017 %>%
  select(NUTS2, Geo_Labels, chg_gdpc, gini, Pop_km2) %>% 
  mutate(
    Density_class = cut(
      Pop_km2,
      breaks = c(0, 300, 1500, Inf),
      labels = c("Rural", "Medium Density", "High Density"),
      include.lowest = TRUE
    )
  )

```

```{r}
#| label: tbl-MLR
#| fig-cap: "Multiple Regression - Regional GDP Inequality as a function of GDP and population density."
as_flextable (lm(gini ~ chg_gdpc + Pop_km2, data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
```

```{r}
High_Density_reg <- Pop_km2_segm %>%
  filter(Density_class == "High") %>%
  lm(formula = gini ~ chg_gdpc)
Medium_Density_reg <- Pop_km2_segm %>%
  filter(Density_class == "Medium") %>%
  lm(formula = gini ~ chg_gdpc)
Low_Density_reg <- Pop_km2_segm %>%
  filter(Density_class == "Low") %>%
  lm(formula = gini ~ chg_gdpc)
```

```{r}
xsection2017 %>%
  filter(Density_class == "High") %>%
  lm(formula = gini ~ chg_gdpc) + 
  xsection2017 %>%
  filter(Density_class == "Medium") %>%
  lm(formula = gini ~ chg_gdpc) + 
  xsection2017 %>%
  filter(Density_class == "Rural") %>%
  lm(formula = gini ~ chg_gdpc)
```

## Workforce

Our data on available workforce is much more linear than for population density, so here we will simply be doing a quantile split into three equally sized classifications: "low", "medium" and "high" workforce.

```{r}
#Workforce
Workforce_segm <- xsection2017 %>%
  select(NUTS2, Geo_Labels, chg_gdpc, gini, Workforce) %>% 
  mutate(Workforce_Class = cut(Workforce,
                           breaks = quantile(Workforce, probs = c(0, 1/3, 2/3, 1), na.rm = TRUE),
                           include.lowest = TRUE,
                           labels = c("Low", "Medium", "High")))

```

## Unemployment Rate

```{r}
Unemp_prct_segm <- xsection2017 %>%
  mutate(
    Unemp_Class = cut(
      Unemp_prct,
      breaks = c(0, 5, 10, Inf),
      labels = c("Low", "Medium", "High"),
      include.lowest = TRUE
    )
  )

```

```{r}
ggplot(Pop_km2_segm, aes(x = chg_gdpc, y = gini)) +
geom_point(data = Pop_km2_segm %>%
            filter(Segments == "High"))
```


--------------------------------------------------------------------

## Part B Exploring Alternative Functional forms
-Functional form exploration:
Here we are chosing two of three alternative functional forms logarithmic, quadratic and cubic, to see which is a better fit. 


```{r}
# Creating different functional forms for change in gdpc
# Linear funksjon
as_flextable (lm(gini ~ chg_gdpc, data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
liner_Unemp <- lm(gini ~ chg_gdpc, data = xsection2017)

# Logarithmic:
as_flextable (lm(gini ~ log(chg_gdpc), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
Log_Unemp <- lm(gini ~ log(chg_gdpc), data = xsection2017)

#Quadratic:
as_flextable (lm(gini ~ chg_gdpc + I(chg_gdpc^2), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
Kvad_Unemp <- lm(gini ~ chg_gdpc + I(chg_gdpc^2), data = xsection2017)
```
Modell 1 og 2 passer best for denne variabelen, forklar 
For the employment rate we have chosen the logarithmic and the quadratic functions to see if they provide a better fit. Model one gives a p-verdi for hele modellen på en 0.0018 noe som viser at modellen forklarer en variasjon i repsonsvariablene. Så får vi en R²=0.27 som sier at modellen har en 27% forklaringskraft på den 
The first model is the logarithmic function which gives a estimated value of 0.233016 when all explanatory variables are 0


```{r}
# Creating different functional forms for Labour force 
# Linear function
as_flextable(lm(gini ~ chg_gdpc, data = xsection2017)
linear_Pop_km2 <- lm(gini ~ chg_gdpc, data = xsection2017)

# Logarithmic function:
as_flextable (lm(gini ~ log(Workforce), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)

#Quadratic function:
as_flextable (lm(gini ~ Workforce + I(Workforce^2), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
```
Modell 1 og modell 2 er de jeg kan bruke men begge har en svært lav forklaringskraft på hvordan workforce påvirker den regional ulikeheten, kan dette være fordi det er der forskjeller i fra den lave til høy?

```{r}
# Creating different functional forms for Population density 
# Linear function
as_flextable(lm(gini ~ Pop_km2, data = xsection2017)
linear_Pop_km2 <- lm(gini ~ Pop_km2, data = xsection2017))
# Logarithmic function:
as_flextable (lm(gini ~ log(Pop_km2), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
Log_Pop_km2 <- lm(gini ~ log(Pop_km2), data = xsection2017)

#Quadratic function:
as_flextable (lm(gini ~ Pop_km2 + I(Pop_km2^2), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
Kvad_Pop_km2 <- lm(gini ~ Pop_km2 + I(Pop_km2^2), data = xsection2017)
```

```{r}
# Creating different functional forms for Population density 
# Linear function
as_flextable(lm(gini ~ Unemp_prct, data = xsection2017))
linear_Unemp <- (lm(gini ~ Unemp_prct, data = xsection2017))
# Logarithmic function:
as_flextable (lm(gini ~ log(Unemp_prct), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
Log_Pop_km2 <- lm(gini ~ log(Unemp_prct), data = xsection2017)

#Quadratic function:
as_flextable (lm(gini ~ Unemp_prct + I(Unemp_prct^2), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
Kvad_Pop_km2 <- lm(gini ~ Unemp_prct + I(Unemp_prct^2), data = xsection2017)
```



```{r}
linear_Pop_km2 |> # creating a linear regression line 
  ggplot(
    mapping = aes(
      x = liner_Pop_km2$residuals, 
      y = liner_Pop_km2$fitted.values
    )
  ) +
  geom_jitter(
    size = 1,
    alpha = 0.70
  ) +
  geom_smooth(linewidth = 1, 
    colour = "blue"
    )+
  xlab("Population density") +
  ylab("Gini")

Log_Pop_km2 |> # creating a logarithmic regression line 
  ggplot(
    mapping = aes(
      x = Log_Pop_km2$residuals,
      y = Log_Pop_km2$fitted.values
    )
  ) +
  geom_jitter(
    size = 1,
    alpha = 0.70
  ) +
  geom_smooth(linewidth = 1, 
    colour = "blue"
    )+
  xlab("Population density") +
  ylab("Gini")

Kvad_Pop_km2 |>
  ggplot(
    mapping = aes(
      x = Kvad_Pop_km2$residuals,
      y = Kvad_Pop_km2$fitted.values
    )
  ) +
  geom_jitter(
    size = 1,
    alpha = 0.70
  ) +
  geom_smooth(
    linewidth = 1, 
    colour = "blue"
    )+
  xlab("Population density") +
  ylab("Gini")
```




