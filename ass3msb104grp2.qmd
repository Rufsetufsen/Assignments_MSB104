---
title: "Assignment 3:"
subtitle:  "Regional GDP Inequality in 4 Selected European Economies - "
author: "Kristoffer Tufta and Harald Vika"
date: last-modified
date-format: "dddd D MMM, YYYY"
csl: apa7.csl
lang: en-GB
format:
  html: default
  typst:
    papersize: a4
  pdf: 
    documentclass: article
    number-sections: true
    keep-tex: true
    papersize: A4
    fig-pos: "H"
abstract: ""
editor: 
  markdown: 
    wrap: sentence
echo: false
bibliography: references.bib
---

```{r}
#| label: setup
#| include: FALSE
#| message: false
#| warning: false
library (tidyverse)
library (PxWebApiData)
library(readxl)
library(purrr)
library(dineq)
library(psych)
library(flextable)
library(modelsummary)
library(lmtest)

```

\# Part A: Testing development effects across subsets

```{r}
full_dataset <- readRDS("./data/Gini_EUdata_Full.rds")
```

## Population Density

Breaking down our population density into logical segments could help us make a more accurate regression line.
If we take a look at our dataset, the data varies a lot, where we have many rural regions with low population density, and then some large city-regions with a much higher density.
To define the classifications, we will be taking inspiration from Eurostat's own definition on urban clusters and density, which divides Europe into:

-   *"Urban centre (high-density cluster): a cluster of contiguous grid cells of 1 km² (excluding diagonals) with a population density of at least 1 500 inhabitants per km² and collectively a minimum population of 50 000 inhabitants after gap-filling*
-   *Urban cluster (moderate-density cluster): a cluster of contiguous grid cells of 1 km² (including diagonals) with a population density of at least 300 inhabitants per km² and a minimum population of 5 000 inhabitants*
-   *Rural grid cells: grid cells that aren’t identified as urban centres or as urban clusters."*

[@populati]

Their classification is based on continuous cell clusters of one square kilometer cells , whereas ours is for whole NUTS2-regions, but we will be using the same break values.

```{r}
#Population Density Segmenting.
full_dataset <- full_dataset %>%
  select(NUTS2, Geo_Labels, chg_gdpc, gini, Pop_km2) %>% 
  mutate(
    Segments = cut(
      Pop_km2,
      breaks = c(0, 300, 1500, Inf),
      labels = c("Rural", "Medium Density", "High Density"),
      include.lowest = TRUE
    )
  )

```



```{r}
#| label: tbl-MLR
#| fig-cap: "Multiple Regression - Regional GDP Inequality as a function of GDP and population density."
as_flextable (lm(gini ~ chg_gdpc + Pop_km2, data = full_dataset
))%>%
  colformat_double(j = 2, digits = 6)
```

```{r}
High_Density_reg <- Pop_km2_segm %>%
  filter(Segments == "High") %>%
  lm(formula = gini ~ chg_gdpc)
Medium_Density_reg <- Pop_km2_segm %>%
  filter(Segments == "Medium") %>%
  lm(formula = gini ~ chg_gdpc)
Low_Density_reg <- Pop_km2_segm %>%
  filter(Segments == "Low") %>%
  lm(formula = gini ~ chg_gdpc)
```

```{r}
full_dataset %>%
  filter(Segments == "High") %>%
  lm(formula = gini ~ chg_gdpc) + 
  full_dataset %>%
  filter(Segments == "Medium") %>%
  lm(formula = gini ~ chg_gdpc) + 
  full_dataset %>%
  filter(Segments == "Rural") %>%
  lm(formula = gini ~ chg_gdpc)
```



## Workforce
Our data on available workforce is much more linear than for population density, so here we will simply be doing a quantile split into three equally sized classifications: "low", "medium" and "high" workforce.
```{r}
#Workforce
Workforce_segm <- full_dataset %>%
  select(NUTS2, Geo_Labels, chg_gdpc, gini, Workforce) %>% 
  mutate(Segments = cut(Workforce,
                           breaks = quantile(Workforce, probs = c(0, 1/3, 2/3, 1), na.rm = TRUE),
                           include.lowest = TRUE,
                           labels = c("Low", "Medium", "High")))

```

## Unemployment Rate

```{r}
#Unemployment rate
Unemp_prct_segm <- full_dataset %>%
  mutate(
    Unemp_prct = cut(
      Unemp_prct,
      breaks = c(0, 5, 10, Inf),
      labels = c("Low", "Medium", "High"),
      include.lowest = TRUE
    )
  )

```



```{r}
ggplot(Pop_km2_segm, aes(x = chg_gdpc, y = gini)) +
geom_point(data = Pop_km2_segm %>%
            filter(Segments == "High"))
```
