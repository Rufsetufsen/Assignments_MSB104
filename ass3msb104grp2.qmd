---
title: "Assignment 3:"
subtitle:  "Regional GDP Inequality in 4 Selected European Economies - "
author: "Kristoffer Tufta and Harald Vika"
date: last-modified
date-format: "dddd D MMM, YYYY"
csl: apa7.csl
lang: en-GB
format:
  html: default
  typst:
    papersize: a4
  pdf: 
    documentclass: article
    number-sections: true
    keep-tex: true
    papersize: A4
    fig-pos: "H"
abstract: ""
editor: 
  markdown: 
    wrap: sentence
echo: false
bibliography: references.bib
---

```{r}
#| label: setup
#| include: FALSE
#| message: false
#| warning: false
library (tidyverse)
library (PxWebApiData)
library(readxl)
library(purrr)
library(dineq)
library(psych)
library(flextable)
library(modelsummary)
library(lmtest)

```

<<<<<<< HEAD
=======
\# Part A: Testing development effects across subsets

```{r}
#Reading prewritten datasets
full_dataset <- readRDS("./data/tidyjoined2.rds")
xsection2017<- readRDS("./data/Gini_EUdata_full.rds") 
```


## Population Density

Breaking down our population density into logical segments could help us make a more accurate regression line.
If we take a look at our dataset, the data varies a lot, where we have many rural regions with low population density, and then some large city-regions with a much higher density.
To define the classifications, we will be taking inspiration from Eurostat's own definition on urban clusters and density, which divides Europe into:

-   *"Urban centre (high-density cluster): a cluster of contiguous grid cells of 1 km² (excluding diagonals) with a population density of at least 1 500 inhabitants per km² and collectively a minimum population of 50 000 inhabitants after gap-filling*
-   *Urban cluster (moderate-density cluster): a cluster of contiguous grid cells of 1 km² (including diagonals) with a population density of at least 300 inhabitants per km² and a minimum population of 5 000 inhabitants*
-   *Rural grid cells: grid cells that aren’t identified as urban centres or as urban clusters."*

[@populati]

Their classification is based on continuous cell clusters of one square kilometer cells , whereas ours is for whole NUTS2-regions, but we will be using the same break values.

```{r}
#Population density
xsection2017 <- xsection2017 %>%
  select(NUTS2, Geo_Labels, chg_gdpc, gini, Pop_km2) %>% 
  mutate(
    Density_class = cut(
      Pop_km2,
      breaks = c(0, 300, 1500, Inf),
      labels = c("Rural", "Medium Density", "High Density"),
      include.lowest = TRUE
    )
  )

```

```{r}
#| label: tbl-MLR
#| fig-cap: "Multiple Regression - Regional GDP Inequality as a function of GDP and population density."
as_flextable (lm(gini ~ chg_gdpc + Pop_km2, data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
```

```{r}
High_Density_reg <- Pop_km2_segm %>%
  filter(Density_class == "High") %>%
  lm(formula = gini ~ chg_gdpc)
Medium_Density_reg <- Pop_km2_segm %>%
  filter(Density_class == "Medium") %>%
  lm(formula = gini ~ chg_gdpc)
Low_Density_reg <- Pop_km2_segm %>%
  filter(Density_class == "Low") %>%
  lm(formula = gini ~ chg_gdpc)
```

```{r}
xsection2017 %>%
  filter(Density_class == "High") %>%
  lm(formula = gini ~ chg_gdpc) + 
  xsection2017 %>%
  filter(Density_class == "Medium") %>%
  lm(formula = gini ~ chg_gdpc) + 
  xsection2017 %>%
  filter(Density_class == "Rural") %>%
  lm(formula = gini ~ chg_gdpc)
```

## Workforce

Our data on available workforce is much more linear than for population density, so here we will simply be doing a quantile split into three equally sized classifications: "low", "medium" and "high" workforce.

```{r}
#Workforce
Workforce_segm <- xsection2017 %>%
  select(NUTS2, Geo_Labels, chg_gdpc, gini, Workforce) %>% 
  mutate(Workforce_Class = cut(Workforce,
                           breaks = quantile(Workforce, probs = c(0, 1/3, 2/3, 1), na.rm = TRUE),
                           include.lowest = TRUE,
                           labels = c("Low", "Medium", "High")))

```

## Unemployment Rate

```{r}
Unemp_prct_segm <- xsection2017 %>%
  mutate(
    Unemp_Class = cut(
      Unemp_prct,
      breaks = c(0, 5, 10, Inf),
      labels = c("Low", "Medium", "High"),
      include.lowest = TRUE
    )
  )

```

```{r}
ggplot(Pop_km2_segm, aes(x = chg_gdpc, y = gini)) +
geom_point(data = Pop_km2_segm %>%
            filter(Segments == "High"))
```



```{r}
log_model <- lm(gini ~ chg_gdpc + log(Unemp_prct), data = xsection2017)

kubisk_model <- lm(gini ~ chg_gdpc + Unemp_prct + I(Unemp_prct^2) + I(Unemp_prct^2), data = xsection2017)
```

```{r}
# Unemployment rate forskjellige funksjoner:
# Logaritmisk:
as_flextable (lm(gini ~ chg_gdpc + log(Unemp_prct), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)

#Kvadratisk:
as_flextable (lm(gini ~ chg_gdpc + I(Unemp_prct^2), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)

#Kubisk:
as_flextable(lm(gini ~ chg_gdpc + Unemp_prct + I(Unemp_prct^2) + I(Unemp_prct^3), data = xsection2017))
```
Modell 2 og 3 passer best for unemployment rate, forklar hvorfor 

```{r}
# workforce forskjellige funksjoner:
# Logaritmisk:
as_flextable (lm(gini ~ chg_gdpc + log(Workforce), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)
testmodel <- as_flextable (lm(gini ~ chg_gdpc + log(Workforce), data = xsection2017
))

#Kvadratisk:
as_flextable (lm(gini ~ chg_gdpc + I(Workforce^2), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)

#Kubisk:
as_flextable(lm(gini ~ chg_gdpc + Workforce + I(Workforce^2) + I(Workforce^3), data = xsection2017))
```
Modell 1 og modell 2 er de jeg kan bruke men begge har en svært lav forklaringskraft på hvordan workforce påvirker den regional ulikeheten, kan dette være fordi det er der forskjeller i fra den lave til høy?

```{r}
# Set seed
{set.seed(1234)
# Sample size
n <- 1e3
# Generate data
log_df <- tibble(
  x = runif(n, 0, 10),
  y = exp(3 * log(x) + rnorm(n, sd = 0.5))
)
reg3 <- lm(log(y) ~ log(x), log_df)
a3 <- round(reg3$coefficients[1], 3)
b3 <- round(reg3$coefficients[2], 3)
}
```

```{r}
plot_log_log <- ggplot(data = log_df, aes(x = x, y = y)) +
geom_point(size = 1.5, colour = "orange", alpha = 0.2) +
geom_smooth(linewidth = 1.5, colour = "blue", se = FALSE) +
xlab("X") +
ylab("Y") +
  labs(title = bquote('log('~hat(Y)[i]~')='~.(a3)~ + .(b3)~'·'~'log('~X[i]~')'))
# to get rid of message from geom_smooth
suppressMessages(print(plot_log_log))
```




```{r}
quad_reg <- lm(gini ~ Workforce + I(Workforce^2), data = xsection2017) 
coef_q_reg <- coef(quad_reg)
b1 <- coef_q_reg[2]
b2 <- coef_q_reg[3]
```

```{r}
p_quad <- xsection2017 |> 
  ggplot(mapping = aes(x = Workforce, y = gini)) +
  geom_point(size = 1.5, colour = "orange", alpha = 0.2) +
  geom_smooth(
    method = "lm", 
    formula = y ~ x + I(x^2),
    linewidth = 1.5, 
    colour = "blue", 
    se = FALSE
  ) +
  xlab("Workforce") +
  ylab("Gini")

suppressMessages(print(p_quad))
```


```{r}
# Population density forskjellige funksjoner:
# Logaritmisk:
as_flextable (lm(gini ~ chg_gdpc + log(Pop_km2), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)

#Kvadratisk:
as_flextable (lm(gini ~ chg_gdpc + I(Pop_km2^2), data = xsection2017
))%>%
  colformat_double(j = 2, digits = 6)

#Kubisk:
as_flextable(lm(gini ~ chg_gdpc + Pop_km2 + I(Pop_km2^2) + I(Pop_km2^3), data = xsection2017))
```
```


