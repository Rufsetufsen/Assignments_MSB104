---
title: "ass1msb104grp2"
format: html
editor: visual
---

```{r}
#| label: setup
library (tidyverse)
library (PxWebApiData)
library(readxl)
library(purrr)
library(dineq)
```

## Data Acquisition

### GDP per Region

```{r}
#Removing the metadata from the top and bottom by defining the range.
raw_econ <- read_excel("./Data/GDP_noFlag.xlsx", sheet = "Sheet 1", range = "A8:Y464", col_types = "text")
#Dropping the first row to align time with years
  raw_econ <- raw_econ[-1,]
  names(raw_econ)[1] <- "Geo_Labels"
print(raw_econ)
```

```{r}
# Making raw_econ into long format.
tidy_econ <- pivot_longer(data = raw_econ,
             cols = -Geo_Labels,
             names_to = "Time",
             values_to = "GDP Million EUR")

```

### Demographic Data

```{r}
#Removing the metadata from the top.
raw_demo <- read_excel("./Data/demo_noFlag.xlsx", sheet = "Sheet 1", range = "A10:Z487", col_types = "text")
#Dropping the first row to align time with years
  raw_demo <- raw_demo[-1,]
  names(raw_demo)[1] <- "Geo_Codes"
  names(raw_demo)[2] <- "Geo_Labels"
print(raw_demo)
```

```{r}
# Making raw_demo into long format.
tidy_demo <- pivot_longer(data = raw_demo,
             cols = c(-Geo_Codes, -Geo_Labels),
             names_to = "Time",
             values_to = "Population")

```

## GDP Per capita:

```{r}
# Joining the two datasets
tidyjoined <- left_join(tidy_demo, tidy_econ, by = join_by(Geo_Labels, Time), keep = FALSE)
# Mutating to add column for GDP per capita.
 tidyjoined <- tidyjoined %>%
    mutate(
    `GDP Million EUR` = as.numeric(`GDP Million EUR`),
    Population = as.numeric(Population),
    GDP_Capita = (`GDP Million EUR` * 1000000) / Population
  )
 tidyjoined <- tidyjoined %>%
   mutate(Country = substr(Geo_Codes, 1, 2), .before = 2)
 tidyjoined <- tidyjoined %>%
   mutate( NUTS2 = (str_sub(Geo_Codes, start= 1L, end = 4L)), .before = 2)
head(tidyjoined, 15)
```

```{r}
sum(is.na(tidyjoined))
```

```{r}
summary(tidyjoined)
```

## Regional GDP inequality - Using light levels as a predictor of economic development

In this assignment we use reported GDP and demographic data from Eurostat to determine regional inequality in a selection of countries, but what can you do when regional income data isn’t readily available? The paper “Regional inequality, convergence, and its determinants – A view from outer space” by Christian Lessmann and André Seidel aimed to find a new way of finding regional inequalities in areas without economic data – estimating regional income using satellite images of nighttime light intensity.

Their method involved using luminosity data taken from meteorological satellites from the U.S air force, and existing income data to estimate a relationship between the two variables. They then used this estimate to predict regional income for other regions where economic data was not available, and to calculate inequality indicators such as the Gini coefficient.
The main takeaway from the study would be that yes – it is possible to use light as an indicator of GDP. Findings also showed that for about 70% of countries, regional gaps got smaller, while other countries saw inequality grow. They also discovered an “n-shaped” link between development and regional inequality: in early stages of growth inequality is low, for mid-income regions it rises, before it falls again in rich economies. 


## Regional GDP inequality - Calculating the Gini coefficient

To calculate the Gini coefficient for our selected countries (weighted for population) we first insert our data including GDP per capita into a new function we have called "ginigdp". To be able to calculate the Gini coefficient, we then have to remove NA-values from our dataset. This can be done by using the "na.omit"-function. The output is then grouped by year (variable "Time") and region (NUTS2), and sent to a summarise-function which includes our Gini calculation (done by the "gini.wtd"-function). We have also included a count-column that shows the amount of NUTS3-regions in each of the NUTS2-regions. This is to provide clarity in case we get "strange" Gini-values like 0, which we would represent ultimate equality. We will get this in all cases where there is only one NUTS3-region per NUTS2-region. The code chunk below does all this and prints the first 10 results. 

```{r}
ginigdp <- tidyjoined %>%
  na.omit %>%
  group_by(NUTS2, Time)%>%
  summarise( Count = n(),
            gini = gini.wtd(GDP_Capita, weights = Population))
head(ginigdp, 10)
```

```{r}
#Gini Switzerland
ginigdp %>%
  filter(startsWith(NUTS2, "CH")) %>%
ggplot(mapping = aes(x = Time, y = gini, colour = NUTS2, group = NUTS2)) + 
  geom_point(mapping = aes()) +
  geom_line()
```

```{r}
#Gini Ireland
ginigdp %>%
  filter(startsWith(NUTS2, "IE")) %>%
ggplot(mapping = aes(x = Time, y = gini, colour = NUTS2, group = NUTS2, )) + 
  geom_point(mapping = aes()) + 
  geom_line() +
  labs(x = "Year", y = "Gini-Coefficient", title = "Regional GDP Inequity in Ireland", subtitle = "Broken down by NUTS2-region")
```

```{r}
#Gini Germany
ginigdp %>%
  filter(startsWith(NUTS2, "DE")) %>%
ggplot(mapping = aes(x = Time, y = gini, colour = NUTS2, group = NUTS2)) + 
  geom_point(mapping = aes()) + 
  geom_line() +
  theme(axis.text.x = element_text(angle = 45))
```

```{r}

```

```{r}
#Gini Croatia
ginigdp %>%
  filter(startsWith(NUTS2, "HR")) %>%
ggplot(mapping = aes(x = Time, y = gini, colour = NUTS2, group = NUTS2)) + 
  geom_point(mapping = aes()) + 
  geom_line()
```
